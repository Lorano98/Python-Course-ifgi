# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FirescopeDialog
                                 A QGIS plugin
 This plugin helps the firefighters of Muenster to capture fires and manage the organization of firetrucks
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-07-18
        git sha              : $Format:%H$
        copyright            : (C) 2024 by spacey
        email                : staskiewicz.anne@uni-muenster.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis import processing
import time
import random

from qgis.PyQt import uic, QtWidgets
from PyQt5.QtCore import QDateTime
from qgis.core import QgsProject, QgsFeature, QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsVectorLayer, QgsDistanceArea
from qgis.utils import iface
from qgis.PyQt.QtWidgets import QMessageBox, QFileDialog

from .Brandverwaltung import Ui_Dialog as Brandverwaltung
from .Branderfassung import Ui_Dialog as Branderfassung
from .Fahrzeugverwaltung import Ui_Dialog as Fahrzeugverwaltung

from .pdfFunctions import createPDF

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'BrandMainWidget.ui'))
    
parent = iface.mainWindow()

# Alle Layer laden und in einem Dictionary speichern
# Warnung anzeigen, wenn ein Layer nicht gefunden wird
warning_message = 'Die folgenden Layer m√ºssen sich im Projekt befinden:\n\n{}\n\nBitte die fehlenden Layer hinzuf√ºgen und das Plugin neu starten.\n\nüî¥üò•‚ùåü§¶‚Äç‚ôÄÔ∏èüõ†ü§Øü©∏üò®üìâüë©‚Äçüíªüëé'
layer_names = ["Feuer", "Strassen", "Hausnummern", "edges_muenster", "routes", "Notrufmeldestellen"]
data = {}
missing_layers = []
# √úberpr√ºfen, ob die Layer im Projekt vorhanden sind
for name in layer_names:
    layer_list = QgsProject.instance().mapLayersByName(name)
    if layer_list:
        data[f"layer_{name.lower()}"] = layer_list[0]
    else:
        missing_layers.append(name)

# Wenn fehlende Layer vorhanden sind, eine Warnmeldung anzeigen
if missing_layers:
    QMessageBox.warning(parent, "Warning", warning_message.format('\n'.join(missing_layers)))

class BranderfassungDialog(QtWidgets.QDialog, Branderfassung):
    def __init__(self, parent=None):
        super(BranderfassungDialog, self).__init__(parent)
        self.setupUi(self)
        
        # Setzen des Layers zum Suchen des Stra√üennamen
        self.ComboBoxStrasse.setSourceLayer(data["layer_strassen"])
        self.ComboBoxStrasse.setDisplayExpression("NAME")
        # Event Listener, der feuert, wenn die Kombo-Box ge√§ndert wird
        self.ComboBoxStrasse.currentIndexChanged.connect(self.updateComboBoxHN)

        # Setzen der Brandklassen und √∂ffnen eines Infofensters
        self.ArtFeuer.addItems(["Brandklasse A", "Brandklasse B", "Brandklasse C", "Brandklasse D", "Brandklasse F"])
        self.info.clicked.connect(self.openInfo)

        # Dropdown f√ºr Verst√§rkung
        self.textEditVerstaerkung.addItems(["Ja", "Nein"])

        # Datumsfeld mit aktuellem Datum f√ºllen
        self.dateTimeEdit.setDateTime(QDateTime.currentDateTime())
        self.button.accepted.connect(self.okButton)
    
    def updateComboBoxHN(self):
        current_value = self.ComboBoxStrasse.currentText()
        # Herausfinden des Stra√üenschl√ºssels des ausgew√§hlten Features
        for f in data["layer_strassen"].getFeatures():
            if f["NAME"] == current_value:
                self.strassenschluessel= f["STR_SCHL"]
                break

        # Setzen des Hausnummernlayers, um ihn dann nach der ausgew√§hlten Stra√üe zu filtern
        self.ComboBoxHN.setSourceLayer(data["layer_hausnummern"])
        self.ComboBoxHN.setDisplayExpression("Hsn")
        self.ComboBoxHN.setFilterExpression(f"H_STRSCHL = {self.strassenschluessel}")

    def openInfo(self):
        # Zeigt Infos zu den Brandklassen an
        klassen = {"A": "Br√§nde fester Stoffe, haupts√§chlich organischer Natur, die normalerweise unter Glutbildung verbrennen",
                   "B": "Br√§nde von fl√ºssigen oder fl√ºssig werdenden Stoffen",
                   "C": "Br√§nde von Gasen",
                   "D": "Br√§nde von Metallen",
                   "F": "Br√§nde von Speise√∂len/-fetten (pflanzliche oder tierische √ñle und Fette) in Frittier- und Fettbackger√§ten und anderen K√ºcheneinrichtungen und -ger√§ten"}
        QMessageBox.information(parent, "Information", f"Brandklasse A:\n{klassen['A']}\n\nBrandklasse B:\n{klassen['B']}\n\nBrandklasse C:\n{klassen['C']}\n\nBrandklasse D:\n{klassen['D']}\n\nBrandklasse F:\n{klassen['F']}")

    def okButton(self):
        # ID f√ºr das Feuer zuf√§llig erstellen
        id = round(random.random() * 100000000)
        # Neues Feature erstellen
        provider = data["layer_feuer"].dataProvider()
        fields = data["layer_feuer"].fields()
        feature_new = QgsFeature(fields)
        
        # Selektieren der ausgew√§hlten Adresse
        hsn = self.ComboBoxHN.currentText()
        data["layer_hausnummern"].selectByExpression(f"Hsn = '{hsn}' and H_STRSCHL = {self.strassenschluessel}")
        sel_hsn = data["layer_hausnummern"].selectedFeatures()[0]

        # Transformieren nach dem Koordinatensystem des Feuerlayers
        crs_from = QgsCoordinateReferenceSystem(data["layer_hausnummern"].crs().postgisSrid())
        crs_to = QgsCoordinateReferenceSystem(data["layer_feuer"].crs().postgisSrid())
        coordinate_transform = QgsCoordinateTransform(crs_from, crs_to, QgsProject.instance())
        geometry_hsn = sel_hsn.geometry()
        geometry_hsn.transform(coordinate_transform)

        # Setzen der Geometrie des neuen Features
        feature_new.setGeometry(geometry_hsn)
        data["layer_hausnummern"].removeSelection()

        anzahl_fahrzeuge = self.spinBoxAnzahlFahrzeuge.value()

        # N√§chste Station finden, die noch Fahrzeuge frei hat
        # Route zu der Station berechnen und in den Routinglayer kopieren
        station = self.routing(id, geometry_hsn, anzahl_fahrzeuge)

        # Alle Infos aus den Feldern holen
        attributes = {
            "id": id,
            "Typ": self.ArtFeuer.currentText(),
            "Num_Gefaeh": self.spinBoxAnzahlGefaehrder.value(),
            "Num_Verlet": self.spinBoxAnzahlVerletzter.value(),
            "Verstaerku": self.textEditVerstaerkung.currentText(),
            "Num_fahrze": anzahl_fahrzeuge,
            "Datum": self.dateTimeEdit.dateTime().toString("yyyy-MM-dd hh:mm:ss"),
            "Strasse": self.ComboBoxStrasse.currentText(),
            "Hausnummer": self.ComboBoxHN.currentText(),
            "Status": "brennend",
            "Station": station
        }

        # Jedes Attribut wird in das neue Feature geschrieben
        for field_name, value in attributes.items():
            feature_new.setAttribute(field_name, value)

        # Hinzuf√ºgen des Feuers
        provider.addFeatures([feature_new])

        # Pr√ºfen, ob Station gefunden wurde
        if station == None:
            QMessageBox.information(parent, "Information", f"Oh nein üò±! Es brennt an folgender Adresse: \nüî•{self.ComboBoxStrasse.currentText()} {self.ComboBoxHN.currentText()}üî•\n\nLeider sind keine Fahrzeuge mehr verf√ºgbar... ü§∑‚Äç‚ôÄÔ∏èü§∑‚Äç‚ôÇÔ∏è")
        else:
            QMessageBox.information(parent, "Information", f"Oh nein üò±! Es brennt an folgender Adresse: \nüî•{self.ComboBoxStrasse.currentText()} {self.ComboBoxHN.currentText()}üî•\n\nHilfe ist unterwegs.\nFolgende Station ist zust√§ndig:\n{station}\nüöíüë©‚Äçüöíüöíüë®‚Äçüöíüöíüö®üöí")
    

    def routing(self,id,geometry_hsn,anz_fahrzeuge):
        # Path f√ºr den entstehenden Layer festlegen. Da man den Layer sp√§ter nicht l√∂schen kann, wird
        # immer wieder ein neuer erstellt im Ordner "Muell"
        directory, filename = os.path.split(data["layer_edges_muenster"].dataProvider().dataSourceUri())
        muell_directory = os.path.join(directory, "muell")

        # Pr√ºfen, ob der Ordner "muell" existiert, und ggf. erstellen
        if not os.path.exists(muell_directory):
            os.makedirs(muell_directory)
            
        path = os.path.join(muell_directory, filename[0:-4] + f"_routing{id}.shp")

        # Create a QgsDistanceArea() instance
        da = QgsDistanceArea()
        da.setEllipsoid("ETRS89")
        
        # Iterieren durch alle Notrufmeldestellen, um die naheste zu finden
        min_dist = float('inf')
        nearest_feature = None
        for f in data["layer_notrufmeldestellen"].getFeatures():
            geom = f.geometry()
            # Berechnen des Abstands
            dist = da.measureLine([geometry_hsn.asPoint(),geom.asPoint()])

            # Pr√ºfen, ob die Station n√§her ist und noch genug Fahrzeuge hat
            if dist < min_dist and int(f["Anz_Fahrze"]) - anz_fahrzeuge >= 0:
                min_dist = dist
                nearest_feature = f

        # Keine Station hat mehr genug Fahrzeuge
        if nearest_feature == None:
            return None

        # Werkzeug Shortest Path
        processing.run("native:shortestpathpointtopoint", 
                       {
                           'INPUT':data["layer_edges_muenster"].dataProvider().dataSourceUri(),
                           'STRATEGY':0,
                           'DIRECTION_FIELD':'',
                           'VALUE_FORWARD':'',
                           'VALUE_BACKWARD':'',
                           'VALUE_BOTH':'',
                           'DEFAULT_DIRECTION':2,
                           'SPEED_FIELD':'',
                           'DEFAULT_SPEED':50,
                           'TOLERANCE':0,
                           'START_POINT':geometry_hsn.asPoint(),
                           'END_POINT':nearest_feature.geometry().asPoint(),
                           'OUTPUT': path
                           }
                        )
        # Laden des Ergebnis-Layers
        routing = QgsVectorLayer(path, "erg_route", "ogr")
        
        provider = data["layer_routes"].dataProvider()
        fields = data["layer_routes"].fields()
        feature_new = QgsFeature(fields)

        # Attribute, die in den Routenlayer geschrieben werden
        attributes = {
            "id": id,
            "Strasse": self.ComboBoxStrasse.currentText(),
            "Hsn": self.ComboBoxHN.currentText()
        }
        # Jedes Attribut wird in das neue Feature geschrieben
        for field_name, value in attributes.items():
            feature_new.setAttribute(field_name, value)

        # Setzen der Geometrie des neuen Features
        for feature in routing.getFeatures():
            geom = feature.geometry()
        feature_new.setGeometry(geom)

        # Route wird hinzugef√ºgt
        provider.addFeatures([feature_new])

        # Fahrzeuge werden von der Station abgezogen
        station = nearest_feature["Name"]
        provider = data["layer_notrufmeldestellen"].dataProvider()
        fields = data["layer_notrufmeldestellen"].fields()
        # Getting access to the layers capabilities
        capabilities = provider.capabilitiesString()
        # Checking if the capabilty is part of the layer
        if "Change Attribute Values" in capabilities:
            # das Feature anhand des Namens ausw√§hlen
            data["layer_notrufmeldestellen"].selectByExpression(f"\"name\"='{station}'", data["layer_notrufmeldestellen"].SetSelection)
            # speichern des gew√§hlten Features
            selectedStation = data["layer_notrufmeldestellen"].selectedFeatures()
            new_count = selectedStation[0]["Anz_Fahrze"] - anz_fahrzeuge
            for feat_id in data["layer_notrufmeldestellen"].selectedFeatureIds():
                # Create a dictionary with column and value to change
                attributes = {fields.indexOf("Anz_Fahrze"):new_count}
                # Use the changeAttributeValues methode from the provider to 
                # process the attribute change for the specific feature id
                provider.changeAttributeValues({feat_id:attributes})
            
            data["layer_notrufmeldestellen"].removeSelection()

        return station

class BrandverwaltungDialog(QtWidgets.QDialog, Brandverwaltung):
    def __init__(self, parent=None):
        super(BrandverwaltungDialog, self).__init__(parent)
        self.setupUi(self)
        self.ComboBoxBrandID.setSourceLayer(data["layer_feuer"])
        self.ComboBoxBrandID.setDisplayExpression("id")
        self.pushButtonBrandStatus.clicked.connect(self.changeStatus)
        self.pushButton.clicked.connect(self.pdf)

    # Status√§nderung
    def changeStatus(self):
    # Status√§nderung von brennt zu gel√∂scht 
        providerF = data["layer_feuer"].dataProvider()
        fields = data["layer_feuer"].fields()
        # Getting access to the layers capabilities
        capabilitiesF = providerF.capabilitiesString()
        # Checking if the capabilty is part of the layer
        if "Change Attribute Values" in capabilitiesF:
            # speichern der gew√§hlten ID aus dem Input
            sID = int(self.ComboBoxBrandID.currentText())
            # das Feature anhand der ID ausw√§hlen
            data["layer_feuer"].selectByExpression(f"\"id\"={sID}", data["layer_feuer"].SetSelection)
            # speichern des gew√§hlten Features
            sFeuer= data["layer_feuer"].selectedFeatures()
            Feuer = sFeuer[0]

        # Wenn das Feuer bereits gel√∂scht ist, wird die Funktion abgebrochen
            if Feuer["Status"] == "geloescht":
                QMessageBox.information(parent,"Information",f"Der Brandstatuts von Brand {sID} ist bereits gel√∂scht yay :)")
                return

            num_Fahrze = int(Feuer["Num_Fahrze"])
            station = Feuer["Station"]

            for feat_id in data["layer_feuer"].selectedFeatureIds():
                # Create a dictionary with column and value to change
                attributesF = {fields.indexOf("Status"):"geloescht",fields.indexOf("Num_Fahrze"):0}
                # Use the changeAttributeValues methode from the provider to 
                # process the attribute change for the specific feature id
                providerF.changeAttributeValues({feat_id:attributesF})
            
            data["layer_feuer"].removeSelection()

    # Fahrzeuge neu sortieren
        if Feuer["Station"] == None:
            QMessageBox.information(parent,"Information",f"Du warst wohl zu sp√§t. Der Brand {sID} ist von selbst ausgegangen. yay :)")
            return
        providerNMS = data["layer_notrufmeldestellen"].dataProvider()
        fieldsNMS = data["layer_notrufmeldestellen"].fields()
        # Getting access to the layers capabilities
        capabilitiesNMS = providerNMS.capabilitiesString()
        # Checking if the capabilty is part of the layer
        if "Change Attribute Values" in capabilitiesNMS:
        # R√ºckrechnen der benutzten Fahrzeuge zur zust√§ndigen Station nach dem L√∂schen
            # Selektion der zust√§ndigen Station
            data["layer_notrufmeldestellen"].selectByExpression(f"\"Name\"LIKE'{station}'", data["layer_notrufmeldestellen"].SetSelection)
            snms= data["layer_notrufmeldestellen"].selectedFeatures()
            nms = snms[0]
            # addition der aktuellen Anzahl der Fahrzeuge an der Station plus die vom Brand zur√ºckkehrenden
            anz_Fahrze = int(nms["Anz_Fahrze"]) + num_Fahrze
            for feat_id in data["layer_notrufmeldestellen"].selectedFeatureIds():
                # Create a dictionary with column and value to change
                attributesNMS = {fieldsNMS.indexOf("Anz_Fahrze"):anz_Fahrze}
                # Use the changeAttributeValues methode from the provider to 
                # process the attribute change for the specific feature id
                providerNMS.changeAttributeValues({feat_id:attributesNMS})
            
            data["layer_notrufmeldestellen"].removeSelection()
        
    # Route l√∂schen
        providerR = data["layer_routes"].dataProvider()
        if "Change Attribute Values" in capabilitiesNMS:
        # R√ºckrechnen der benutzten Fahrzeuge zur zust√§ndigen Station nach dem L√∂schen
            # Selektion der zust√§ndigen Station
            data["layer_routes"].selectByExpression(f"\"id\"={sID}", data["layer_routes"].SetSelection)
            sroute= data["layer_routes"].selectedFeatures()
            # speichern der zugeh√∂rigen Route
            route = sroute[0]
            # l√∂schen der Route
            providerR.deleteFeatures([route.id()])
            
            data["layer_routes"].removeSelection()
    

        QMessageBox.information(parent,"Information",f"Der Brandstatuts von Brand {sID} wurde zu gel√∂scht ge√§ndert und die üöí sind wieder in der Station. Die zugeh√∂rige Route wurde entfernt.")

    # PDF drucken
        # Function to create a pdf
    def pdf(self):
        # speichern der gew√§hlten ID aus dem Input
        sID = int(self.ComboBoxBrandID.currentText())
        # das Feature anhand der ID ausw√§hlen
        data["layer_feuer"].selectByExpression(f"\"id\"={sID}", data["layer_feuer"].SetSelection)
        # speichern des gew√§hlten Features
        sFeuer= data["layer_feuer"].selectedFeatures()
        # Open the file dialog
        output_path = QFileDialog.getSaveFileName(None, "üì• Select save destination ","", '*.pdf')
        if not output_path[0]:
            # User has cancelled
            QMessageBox.warning(parent,"Information","üö´üòä The user cancelled the export!")
        else:
            createPDF(sFeuer[0], output_path[0], parent, data["layer_feuer"])
            

class FahrzeugverwaltungDialog(QtWidgets.QDialog, Fahrzeugverwaltung):
    def __init__(self, parent=None):
        super(FahrzeugverwaltungDialog, self).__init__(parent)
        self.setupUi(self)

        self.ComboBoxStationsID.setSourceLayer(data["layer_notrufmeldestellen"])
        self.pushButtonAddFahrzeug.clicked.connect(lambda: self.changeCount(0))
        self.pushButtonDelFahrzeug.clicked.connect(lambda: self.changeCount(1))

    def changeCount(self,change):
        # speichern des gew√§hlten Namen aus dem Input
        sName = self.ComboBoxStationsID.currentText()
        providerNMS = data["layer_notrufmeldestellen"].dataProvider()
        fieldsNMS = data["layer_notrufmeldestellen"].fields()
        # Getting access to the layers capabilities
        capabilitiesNMS = providerNMS.capabilitiesString()
        # Checking if the capabilty is part of the layer
        if "Change Attribute Values" in capabilitiesNMS:
        # Hinzuf√ºgen oder L√∂schen von Fahrzeugen
            # das Feature anhand des Namen ausw√§hlen
            data["layer_notrufmeldestellen"].selectByExpression(f"\"Name\"LIKE '{sName}'", data["layer_notrufmeldestellen"].SetSelection)
            # speichern des gew√§hlten Features
            sNotrufmeldestelle= data["layer_notrufmeldestellen"].selectedFeatures()
            # Speichern der aktuellen Anzahl an Fahrzeugen
            current_Anz_Fahrze = int(sNotrufmeldestelle[0]["Anz_Fahrze"])

            # √§ndern des Attributs Anz_Fahrze des ausgew√§hlten Features
            for feat_id in data["layer_notrufmeldestellen"].selectedFeatureIds():
            # wenn hinzuf√ºgen geklickt wurde:
                if change == 0:
                    new_val = current_Anz_Fahrze + 1
                    # Create a dictionary with column and value to change
                    attributesNMS = {fieldsNMS.indexOf("Anz_Fahrze"):new_val}
                    # Use the changeAttributeValues methode from the provider to 
                    # process the attribute change for the specific feature id
                    providerNMS.changeAttributeValues({feat_id:attributesNMS})
                    QMessageBox.information(parent,"Information",f"Die Anzahl der üöí an der Station: {sName} wurde um +1 erh√∂ht :)")
                # wenn gel√∂scht geklickt wurde:
                else:
                    # Pr√ºfen, ob die Anzahl bereits auf 0 ist
                    if current_Anz_Fahrze == 0:
                        QMessageBox.information(parent,"Information",f"Die Anzahl der üöí an der Station: {sName} ist bereits 0")
                    else:
                        new_val = current_Anz_Fahrze - 1
                        # Create a dictionary with column and value to change
                        attributesNMS = {fieldsNMS.indexOf("Anz_Fahrze"):new_val}
                        # Use the changeAttributeValues methode from the provider to 
                        # process the attribute change for the specific feature id
                        providerNMS.changeAttributeValues({feat_id:attributesNMS})
                        QMessageBox.information(parent,"Information",f"Die Anzahl der üöí an der Station: {sName} wurde um -1 verringert :(")
        # Auswahl aufheben
        data["layer_notrufmeldestellen"].removeSelection()
        
def openBranderfassung(self):
    dialog = BranderfassungDialog()
    dialog.exec_()

def openBrandverwaltung(self):
    dialog = BrandverwaltungDialog()
    dialog.exec_()

def openFahrzeugverwaltung(self):
    dialog = FahrzeugverwaltungDialog()
    dialog.exec_()

class FirescopeDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(FirescopeDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        
        self.pushButtonFeuerVerwalten.clicked.connect(openBrandverwaltung)
        self.pushButtonFeuerAnlegen.clicked.connect(openBranderfassung)
        self.pushButtonFahrzeugeVerwalten.clicked.connect(openFahrzeugverwaltung)
