# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FirescopeDialog
                                 A QGIS plugin
 This plugin helps the firefighters of Muenster to capture fires and manage the organization of firetrucks
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-07-18
        git sha              : $Format:%H$
        copyright            : (C) 2024 by spacey
        email                : staskiewicz.anne@uni-muenster.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis import processing
import time
import random

from qgis.PyQt import uic, QtWidgets
from PyQt5.QtCore import QDateTime
from qgis.core import QgsProject, QgsFeature, QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsVectorLayer, QgsDistanceArea
from qgis.utils import iface
from qgis.PyQt.QtWidgets import QMessageBox, QFileDialog

from .Brandverwaltung import Ui_Dialog as Brandverwaltung
from .Branderfassung import Ui_Dialog as Branderfassung
from .Fahrzeugverwaltung import Ui_Dialog as Fahrzeugverwaltung

from .pdfFunctions import createPDF

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'BrandMainWidget.ui'))
    
parent = iface.mainWindow()

# Alle Layer laden und in einem Dictionary speichern
# Warnung anzeigen, wenn ein Layer nicht gefunden wird
warning_message = 'Die folgenden Layer müssen sich im Projekt befinden:\n\n{}\n\nBitte die fehlenden Layer hinzufügen und das Plugin neu starten.\n\n🔴😥❌🤦‍♀️🛠🤯🩸😨📉👩‍💻👎'
layer_names = ["Feuer", "Strassen", "Hausnummern", "edges_muenster", "routes", "Notrufmeldestellen"]
data = {}
missing_layers = []
# Überprüfen, ob die Layer im Projekt vorhanden sind
for name in layer_names:
    layer_list = QgsProject.instance().mapLayersByName(name)
    if layer_list:
        data[f"layer_{name.lower()}"] = layer_list[0]
    else:
        missing_layers.append(name)

# Wenn fehlende Layer vorhanden sind, eine Warnmeldung anzeigen
if missing_layers:
    QMessageBox.warning(parent, "Warning", warning_message.format('\n'.join(missing_layers)))

class BranderfassungDialog(QtWidgets.QDialog, Branderfassung):
    def __init__(self, parent=None):
        super(BranderfassungDialog, self).__init__(parent)
        self.setupUi(self)
        
        # Setzen des Layers zum Suchen des Straßennamen
        self.ComboBoxStrasse.setSourceLayer(data["layer_strassen"])
        self.ComboBoxStrasse.setDisplayExpression("NAME")
        # Event Listener, der feuert, wenn die Kombo-Box geändert wird
        self.ComboBoxStrasse.currentIndexChanged.connect(self.updateComboBoxHN)

        # Setzen der Brandklassen und öffnen eines Infofensters
        self.ArtFeuer.addItems(["Brandklasse A", "Brandklasse B", "Brandklasse C", "Brandklasse D", "Brandklasse F"])
        self.info.clicked.connect(self.openInfo)

        # Dropdown für Verstärkung
        self.textEditVerstaerkung.addItems(["Ja", "Nein"])

        # Datumsfeld mit aktuellem Datum füllen
        self.dateTimeEdit.setDateTime(QDateTime.currentDateTime())
        self.button.accepted.connect(self.okButton)
    
    def updateComboBoxHN(self):
        current_value = self.ComboBoxStrasse.currentText()
        # Herausfinden des Straßenschlüssels des ausgewählten Features
        for f in data["layer_strassen"].getFeatures():
            if f["NAME"] == current_value:
                self.strassenschluessel= f["STR_SCHL"]
                break

        # Setzen des Hausnummernlayers, um ihn dann nach der ausgewählten Straße zu filtern
        self.ComboBoxHN.setSourceLayer(data["layer_hausnummern"])
        self.ComboBoxHN.setDisplayExpression("Hsn")
        self.ComboBoxHN.setFilterExpression(f"H_STRSCHL = {self.strassenschluessel}")

    def openInfo(self):
        # Zeigt Infos zu den Brandklassen an
        klassen = {"A": "Brände fester Stoffe, hauptsächlich organischer Natur, die normalerweise unter Glutbildung verbrennen",
                   "B": "Brände von flüssigen oder flüssig werdenden Stoffen",
                   "C": "Brände von Gasen",
                   "D": "Brände von Metallen",
                   "F": "Brände von Speiseölen/-fetten (pflanzliche oder tierische Öle und Fette) in Frittier- und Fettbackgeräten und anderen Kücheneinrichtungen und -geräten"}
        QMessageBox.information(parent, "Information", f"Brandklasse A:\n{klassen['A']}\n\nBrandklasse B:\n{klassen['B']}\n\nBrandklasse C:\n{klassen['C']}\n\nBrandklasse D:\n{klassen['D']}\n\nBrandklasse F:\n{klassen['F']}")

    def okButton(self):
        # ID für das Feuer zufällig erstellen
        id = round(random.random() * 100000000)
        # Neues Feature erstellen
        provider = data["layer_feuer"].dataProvider()
        fields = data["layer_feuer"].fields()
        feature_new = QgsFeature(fields)
        
        # Selektieren der ausgewählten Adresse
        hsn = self.ComboBoxHN.currentText()
        data["layer_hausnummern"].selectByExpression(f"Hsn = '{hsn}' and H_STRSCHL = {self.strassenschluessel}")
        sel_hsn = data["layer_hausnummern"].selectedFeatures()[0]

        # Transformieren nach dem Koordinatensystem des Feuerlayers
        crs_from = QgsCoordinateReferenceSystem(data["layer_hausnummern"].crs().postgisSrid())
        crs_to = QgsCoordinateReferenceSystem(data["layer_feuer"].crs().postgisSrid())
        coordinate_transform = QgsCoordinateTransform(crs_from, crs_to, QgsProject.instance())
        geometry_hsn = sel_hsn.geometry()
        geometry_hsn.transform(coordinate_transform)

        # Setzen der Geometrie des neuen Features
        feature_new.setGeometry(geometry_hsn)
        data["layer_hausnummern"].removeSelection()

        anzahl_fahrzeuge = self.spinBoxAnzahlFahrzeuge.value()

        # Nächste Station finden, die noch Fahrzeuge frei hat
        # Route zu der Station berechnen und in den Routinglayer kopieren
        station = self.routing(id, geometry_hsn, anzahl_fahrzeuge)

        # Alle Infos aus den Feldern holen
        attributes = {
            "id": id,
            "Typ": self.ArtFeuer.currentText(),
            "Num_Gefaeh": self.spinBoxAnzahlGefaehrder.value(),
            "Num_Verlet": self.spinBoxAnzahlVerletzter.value(),
            "Verstaerku": self.textEditVerstaerkung.currentText(),
            "Num_fahrze": anzahl_fahrzeuge,
            "Datum": self.dateTimeEdit.dateTime().toString("yyyy-MM-dd hh:mm:ss"),
            "Strasse": self.ComboBoxStrasse.currentText(),
            "Hausnummer": self.ComboBoxHN.currentText(),
            "Status": "brennend",
            "Station": station
        }

        # Jedes Attribut wird in das neue Feature geschrieben
        for field_name, value in attributes.items():
            feature_new.setAttribute(field_name, value)

        # Hinzufügen des Feuers
        provider.addFeatures([feature_new])

        # Prüfen, ob Station gefunden wurde
        if station == None:
            QMessageBox.information(parent, "Information", f"Oh nein 😱! Es brennt an folgender Adresse: \n🔥{self.ComboBoxStrasse.currentText()} {self.ComboBoxHN.currentText()}🔥\n\nLeider sind keine Fahrzeuge mehr verfügbar... 🤷‍♀️🤷‍♂️")
        else:
            QMessageBox.information(parent, "Information", f"Oh nein 😱! Es brennt an folgender Adresse: \n🔥{self.ComboBoxStrasse.currentText()} {self.ComboBoxHN.currentText()}🔥\n\nHilfe ist unterwegs.\nFolgende Station ist zuständig:\n{station}\n🚒👩‍🚒🚒👨‍🚒🚒🚨🚒")
    

    def routing(self,id,geometry_hsn,anz_fahrzeuge):
        # Path für den entstehenden Layer festlegen. Da man den Layer später nicht löschen kann, wird
        # immer wieder ein neuer erstellt im Ordner "Muell"
        directory, filename = os.path.split(data["layer_edges_muenster"].dataProvider().dataSourceUri())
        muell_directory = os.path.join(directory, "muell")

        # Prüfen, ob der Ordner "muell" existiert, und ggf. erstellen
        if not os.path.exists(muell_directory):
            os.makedirs(muell_directory)
            
        path = os.path.join(muell_directory, filename[0:-4] + f"_routing{id}.shp")

        # Create a QgsDistanceArea() instance
        da = QgsDistanceArea()
        da.setEllipsoid("ETRS89")
        
        # Iterieren durch alle Notrufmeldestellen, um die naheste zu finden
        min_dist = float('inf')
        nearest_feature = None
        for f in data["layer_notrufmeldestellen"].getFeatures():
            geom = f.geometry()
            # Berechnen des Abstands
            dist = da.measureLine([geometry_hsn.asPoint(),geom.asPoint()])

            # Prüfen, ob die Station näher ist und noch genug Fahrzeuge hat
            if dist < min_dist and int(f["Anz_Fahrze"]) - anz_fahrzeuge >= 0:
                min_dist = dist
                nearest_feature = f

        # Keine Station hat mehr genug Fahrzeuge
        if nearest_feature == None:
            return None

        # Werkzeug Shortest Path
        processing.run("native:shortestpathpointtopoint", 
                       {
                           'INPUT':data["layer_edges_muenster"].dataProvider().dataSourceUri(),
                           'STRATEGY':0,
                           'DIRECTION_FIELD':'',
                           'VALUE_FORWARD':'',
                           'VALUE_BACKWARD':'',
                           'VALUE_BOTH':'',
                           'DEFAULT_DIRECTION':2,
                           'SPEED_FIELD':'',
                           'DEFAULT_SPEED':50,
                           'TOLERANCE':0,
                           'START_POINT':geometry_hsn.asPoint(),
                           'END_POINT':nearest_feature.geometry().asPoint(),
                           'OUTPUT': path
                           }
                        )
        # Laden des Ergebnis-Layers
        routing = QgsVectorLayer(path, "erg_route", "ogr")
        
        provider = data["layer_routes"].dataProvider()
        fields = data["layer_routes"].fields()
        feature_new = QgsFeature(fields)

        # Attribute, die in den Routenlayer geschrieben werden
        attributes = {
            "id": id,
            "Strasse": self.ComboBoxStrasse.currentText(),
            "Hsn": self.ComboBoxHN.currentText()
        }
        # Jedes Attribut wird in das neue Feature geschrieben
        for field_name, value in attributes.items():
            feature_new.setAttribute(field_name, value)

        # Setzen der Geometrie des neuen Features
        for feature in routing.getFeatures():
            geom = feature.geometry()
        feature_new.setGeometry(geom)

        # Route wird hinzugefügt
        provider.addFeatures([feature_new])

        # Fahrzeuge werden von der Station abgezogen
        station = nearest_feature["Name"]
        provider = data["layer_notrufmeldestellen"].dataProvider()
        fields = data["layer_notrufmeldestellen"].fields()
        # Getting access to the layers capabilities
        capabilities = provider.capabilitiesString()
        # Checking if the capabilty is part of the layer
        if "Change Attribute Values" in capabilities:
            # das Feature anhand des Namens auswählen
            data["layer_notrufmeldestellen"].selectByExpression(f"\"name\"='{station}'", data["layer_notrufmeldestellen"].SetSelection)
            # speichern des gewählten Features
            selectedStation = data["layer_notrufmeldestellen"].selectedFeatures()
            new_count = selectedStation[0]["Anz_Fahrze"] - anz_fahrzeuge
            for feat_id in data["layer_notrufmeldestellen"].selectedFeatureIds():
                # Create a dictionary with column and value to change
                attributes = {fields.indexOf("Anz_Fahrze"):new_count}
                # Use the changeAttributeValues methode from the provider to 
                # process the attribute change for the specific feature id
                provider.changeAttributeValues({feat_id:attributes})
            
            data["layer_notrufmeldestellen"].removeSelection()

        return station

class BrandverwaltungDialog(QtWidgets.QDialog, Brandverwaltung):
    def __init__(self, parent=None):
        super(BrandverwaltungDialog, self).__init__(parent)
        self.setupUi(self)
        self.ComboBoxBrandID.setSourceLayer(data["layer_feuer"])
        self.ComboBoxBrandID.setDisplayExpression("id")
        self.pushButtonBrandStatus.clicked.connect(self.changeStatus)
        self.pushButton.clicked.connect(self.pdf)

    # Statusänderung
    def changeStatus(self):
    # Statusänderung von brennt zu gelöscht 
        providerF = data["layer_feuer"].dataProvider()
        fields = data["layer_feuer"].fields()
        # Getting access to the layers capabilities
        capabilitiesF = providerF.capabilitiesString()
        # Checking if the capabilty is part of the layer
        if "Change Attribute Values" in capabilitiesF:
            # speichern der gewählten ID aus dem Input
            sID = int(self.ComboBoxBrandID.currentText())
            # das Feature anhand der ID auswählen
            data["layer_feuer"].selectByExpression(f"\"id\"={sID}", data["layer_feuer"].SetSelection)
            # speichern des gewählten Features
            sFeuer= data["layer_feuer"].selectedFeatures()
            Feuer = sFeuer[0]

        # Wenn das Feuer bereits gelöscht ist, wird die Funktion abgebrochen
            if Feuer["Status"] == "geloescht":
                QMessageBox.information(parent,"Information",f"Der Brandstatuts von Brand {sID} ist bereits gelöscht yay :)")
                return

            num_Fahrze = int(Feuer["Num_Fahrze"])
            station = Feuer["Station"]

            for feat_id in data["layer_feuer"].selectedFeatureIds():
                # Create a dictionary with column and value to change
                attributesF = {fields.indexOf("Status"):"geloescht",fields.indexOf("Num_Fahrze"):0}
                # Use the changeAttributeValues methode from the provider to 
                # process the attribute change for the specific feature id
                providerF.changeAttributeValues({feat_id:attributesF})
            
            data["layer_feuer"].removeSelection()

    # Fahrzeuge neu sortieren
        if Feuer["Station"] == None:
            QMessageBox.information(parent,"Information",f"Du warst wohl zu spät. Der Brand {sID} ist von selbst ausgegangen. yay :)")
            return
        providerNMS = data["layer_notrufmeldestellen"].dataProvider()
        fieldsNMS = data["layer_notrufmeldestellen"].fields()
        # Getting access to the layers capabilities
        capabilitiesNMS = providerNMS.capabilitiesString()
        # Checking if the capabilty is part of the layer
        if "Change Attribute Values" in capabilitiesNMS:
        # Rückrechnen der benutzten Fahrzeuge zur zuständigen Station nach dem Löschen
            # Selektion der zuständigen Station
            data["layer_notrufmeldestellen"].selectByExpression(f"\"Name\"LIKE'{station}'", data["layer_notrufmeldestellen"].SetSelection)
            snms= data["layer_notrufmeldestellen"].selectedFeatures()
            nms = snms[0]
            # addition der aktuellen Anzahl der Fahrzeuge an der Station plus die vom Brand zurückkehrenden
            anz_Fahrze = int(nms["Anz_Fahrze"]) + num_Fahrze
            for feat_id in data["layer_notrufmeldestellen"].selectedFeatureIds():
                # Create a dictionary with column and value to change
                attributesNMS = {fieldsNMS.indexOf("Anz_Fahrze"):anz_Fahrze}
                # Use the changeAttributeValues methode from the provider to 
                # process the attribute change for the specific feature id
                providerNMS.changeAttributeValues({feat_id:attributesNMS})
            
            data["layer_notrufmeldestellen"].removeSelection()
        
    # Route löschen
        providerR = data["layer_routes"].dataProvider()
        if "Change Attribute Values" in capabilitiesNMS:
        # Rückrechnen der benutzten Fahrzeuge zur zuständigen Station nach dem Löschen
            # Selektion der zuständigen Station
            data["layer_routes"].selectByExpression(f"\"id\"={sID}", data["layer_routes"].SetSelection)
            sroute= data["layer_routes"].selectedFeatures()
            # speichern der zugehörigen Route
            route = sroute[0]
            # löschen der Route
            providerR.deleteFeatures([route.id()])
            
            data["layer_routes"].removeSelection()
    

        QMessageBox.information(parent,"Information",f"Der Brandstatuts von Brand {sID} wurde zu gelöscht geändert und die 🚒 sind wieder in der Station. Die zugehörige Route wurde entfernt.")

    # PDF drucken
        # Function to create a pdf
    def pdf(self):
        # speichern der gewählten ID aus dem Input
        sID = int(self.ComboBoxBrandID.currentText())
        # das Feature anhand der ID auswählen
        data["layer_feuer"].selectByExpression(f"\"id\"={sID}", data["layer_feuer"].SetSelection)
        # speichern des gewählten Features
        sFeuer= data["layer_feuer"].selectedFeatures()
        # Open the file dialog
        output_path = QFileDialog.getSaveFileName(None, "📥 Select save destination ","", '*.pdf')
        if not output_path[0]:
            # User has cancelled
            QMessageBox.warning(parent,"Information","🚫😊 The user cancelled the export!")
        else:
            createPDF(sFeuer[0], output_path[0], parent, data["layer_feuer"])
            

class FahrzeugverwaltungDialog(QtWidgets.QDialog, Fahrzeugverwaltung):
    def __init__(self, parent=None):
        super(FahrzeugverwaltungDialog, self).__init__(parent)
        self.setupUi(self)

        self.ComboBoxStationsID.setSourceLayer(data["layer_notrufmeldestellen"])
        self.pushButtonAddFahrzeug.clicked.connect(lambda: self.changeCount(0))
        self.pushButtonDelFahrzeug.clicked.connect(lambda: self.changeCount(1))

    def changeCount(self,change):
        # speichern des gewählten Namen aus dem Input
        sName = self.ComboBoxStationsID.currentText()
        providerNMS = data["layer_notrufmeldestellen"].dataProvider()
        fieldsNMS = data["layer_notrufmeldestellen"].fields()
        # Getting access to the layers capabilities
        capabilitiesNMS = providerNMS.capabilitiesString()
        # Checking if the capabilty is part of the layer
        if "Change Attribute Values" in capabilitiesNMS:
        # Hinzufügen oder Löschen von Fahrzeugen
            # das Feature anhand des Namen auswählen
            data["layer_notrufmeldestellen"].selectByExpression(f"\"Name\"LIKE '{sName}'", data["layer_notrufmeldestellen"].SetSelection)
            # speichern des gewählten Features
            sNotrufmeldestelle= data["layer_notrufmeldestellen"].selectedFeatures()
            # Speichern der aktuellen Anzahl an Fahrzeugen
            current_Anz_Fahrze = int(sNotrufmeldestelle[0]["Anz_Fahrze"])

            # ändern des Attributs Anz_Fahrze des ausgewählten Features
            for feat_id in data["layer_notrufmeldestellen"].selectedFeatureIds():
            # wenn hinzufügen geklickt wurde:
                if change == 0:
                    new_val = current_Anz_Fahrze + 1
                    # Create a dictionary with column and value to change
                    attributesNMS = {fieldsNMS.indexOf("Anz_Fahrze"):new_val}
                    # Use the changeAttributeValues methode from the provider to 
                    # process the attribute change for the specific feature id
                    providerNMS.changeAttributeValues({feat_id:attributesNMS})
                    QMessageBox.information(parent,"Information",f"Die Anzahl der 🚒 an der Station: {sName} wurde um +1 erhöht :)")
                # wenn gelöscht geklickt wurde:
                else:
                    # Prüfen, ob die Anzahl bereits auf 0 ist
                    if current_Anz_Fahrze == 0:
                        QMessageBox.information(parent,"Information",f"Die Anzahl der 🚒 an der Station: {sName} ist bereits 0")
                    else:
                        new_val = current_Anz_Fahrze - 1
                        # Create a dictionary with column and value to change
                        attributesNMS = {fieldsNMS.indexOf("Anz_Fahrze"):new_val}
                        # Use the changeAttributeValues methode from the provider to 
                        # process the attribute change for the specific feature id
                        providerNMS.changeAttributeValues({feat_id:attributesNMS})
                        QMessageBox.information(parent,"Information",f"Die Anzahl der 🚒 an der Station: {sName} wurde um -1 verringert :(")
        # Auswahl aufheben
        data["layer_notrufmeldestellen"].removeSelection()
        
def openBranderfassung(self):
    dialog = BranderfassungDialog()
    dialog.exec_()

def openBrandverwaltung(self):
    dialog = BrandverwaltungDialog()
    dialog.exec_()

def openFahrzeugverwaltung(self):
    dialog = FahrzeugverwaltungDialog()
    dialog.exec_()

class FirescopeDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(FirescopeDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        
        self.pushButtonFeuerVerwalten.clicked.connect(openBrandverwaltung)
        self.pushButtonFeuerAnlegen.clicked.connect(openBranderfassung)
        self.pushButtonFahrzeugeVerwalten.clicked.connect(openFahrzeugverwaltung)
